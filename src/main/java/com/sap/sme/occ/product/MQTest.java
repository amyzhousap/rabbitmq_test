package com.sap.sme.occ.product;

import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;

import org.apache.http.HttpEntity;
import org.apache.http.HttpResponse;
import org.apache.http.client.ClientProtocolException;
import org.apache.http.client.ResponseHandler;
import org.apache.http.client.methods.HttpGet;
import org.apache.http.impl.client.CloseableHttpClient;
import org.apache.http.impl.client.HttpClients;
import org.apache.http.util.EntityUtils;
import org.apache.jmeter.util.JMeterUtils;
import org.apache.log.Logger;

import com.rabbitmq.client.AMQP;
import com.rabbitmq.client.Channel;
import com.rabbitmq.client.Connection;
import com.rabbitmq.client.ConnectionFactory;
import com.rabbitmq.client.Consumer;
import com.rabbitmq.client.DefaultConsumer;
import com.rabbitmq.client.Envelope;


public class MQTest {

	public static final int MQ_PORT = 5673; //5672 for CD
	public static final String MQ_HOST = "localhost";//"rabbitmq"; for CD
	public static final int INTERNAL_HTTP_PORT = 58080;

	private static Connection mqConnection;
	private static Channel channel;

	public static Connection getMqConnection() {
		return mqConnection;
	}

	private static List<String> messages = new ArrayList<String>();

	public static List<String> getMessages() {
		return messages;
	}

	public static void killAMQConnection() throws IOException {
		mqConnection.close(0, "");
		mqConnection.abort();
		channel.close(0, "");
		channel.abort();
	}

	public static String startMQ(final Logger logger, final org.apache.jmeter.threads.JMeterVariables vars) throws Exception {
		String ret = "";
		boolean mqStarted = false;
		try {
			LightHttpServer.startHttpServer(INTERNAL_HTTP_PORT, logger);
		} catch (java.net.BindException e) {
			mqStarted = true;
			logger.info(e.getMessage(), e);
			ret = "reusing your last MQ connection, or you can call MQTest.stopMQ(log)/MQTest.clearMessage(log) when you finished one case, "
					+ "otherwise the message generated by your last test is cached.";
			logger.info(ret);
			// now try to clear old messages
			clearMessage(logger);
		} catch (Exception e) {
			logger.warn(e.getMessage(), e);
		}

		if (!mqStarted) {
			startAMQConnection(logger, vars);
			ret = "MQ is connected successfully, waiting for messages";
			logger.info(ret);
			System.out.println(ret);
		}

		return ret;
	}

	private static void startAMQConnection(final Logger logger, final org.apache.jmeter.threads.JMeterVariables vars) throws Exception {
		String host = vars.get("MQTest.mqhost");
		if(host != null && host.length() > 0) {
			logger.info("got host " + host + " from user defined variable...");
		} else {
			logger.info("NO host " + host + " from user defined variable, user localhost as default");
			host = MQ_HOST;
		}
		
		String port = vars.get("MQTest.mqport");
		int intPort = 0;
		try {
			intPort = Integer.parseInt(port);
		} catch (NumberFormatException e) {
			logger.warn(e.getMessage(), e);
		}
		
		if(intPort <= 0) {
			logger.info("incorrect port from user defined variable, use 5673 as default");
			intPort = MQ_PORT;
		} else {
			logger.info("got port " + intPort + " from user defined variable...");
		}
		
		ConnectionFactory factory = new ConnectionFactory();
		factory.setHost(host);
		factory.setPort(intPort);
		factory.setUsername("root");
		factory.setPassword("Initial0");
		mqConnection = factory.newConnection();
		channel = mqConnection.createChannel();

		channel.exchangeDeclare("SharedExchange", "topic", true);
		String queueName = channel.queueDeclare().getQueue();
		channel.queueBind(queueName, "SharedExchange", "Product.UPDATE.*.#");

		messages.clear();

		Consumer consumer = new DefaultConsumer(channel) {
			@Override
			public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties,
					byte[] body) throws IOException {
				String message = new String(body, "UTF-8");
				messages.add(message);
				String output = " [x] Received '" + message + "'";
				System.out.println(output);
				if (logger != null) {
					logger.info(output);
				}
			}
		};
		channel.basicConsume(queueName, true, consumer);
	}

	public static void stopMQ(final Logger logger) throws Exception {
		CloseableHttpClient httpclient = HttpClients.createDefault();
		try {
			HttpGet httpget = new HttpGet("http://localhost:" + INTERNAL_HTTP_PORT + "/exit");
			logger.info("Executing request " + httpget.getRequestLine());
			// Create a custom response handler
			ResponseHandler<String> responseHandler = new ResponseHandler<String>() {
				public String handleResponse(final HttpResponse response) throws ClientProtocolException, IOException {
					int status = response.getStatusLine().getStatusCode();
					if (status >= 200 && status < 300) {
						HttpEntity entity = response.getEntity();
						return entity != null ? EntityUtils.toString(entity) : null;
					} else {
						logger.warn("Unexpected response status: " + status);
						throw new ClientProtocolException("Unexpected response status: " + status);
					}
				}
			};
			String responseBody = httpclient.execute(httpget, responseHandler);
			logger.info("----------------------------------------");
			logger.info(responseBody);
		} finally {
			httpclient.close();
		}
	}

	public static String getMessage(final Logger logger) throws Exception {
		String message = "";
		long sleep = 100;
		int sleepCount = 0;
		while (message == null || message.equals("") || message.equals("[]")) {
			if (sleepCount < 3) {
				Thread.sleep(sleep);
				try {
					message = getAMessage(logger);
				} catch (Exception e) {
					logger.warn(e.getMessage(), e);
					logger.warn("trying again ...");
				}
				sleepCount++;
				sleep = sleep + sleepCount * 100;
			} else {
				logger.info("still can not get message after trying " + sleepCount + " times...");
				break;
			}
		}
		return message;
	}

	private static String getAMessage(final Logger logger) throws Exception {
		CloseableHttpClient httpclient = HttpClients.createDefault();
		try {
			HttpGet httpget = new HttpGet("http://localhost:" + INTERNAL_HTTP_PORT + "/messages");
			logger.info("Executing request " + httpget.getRequestLine());
			// Create a custom response handler
			ResponseHandler<String> responseHandler = new ResponseHandler<String>() {
				public String handleResponse(final HttpResponse response) throws ClientProtocolException, IOException {
					int status = response.getStatusLine().getStatusCode();
					if (status >= 200 && status < 300) {
						HttpEntity entity = response.getEntity();
						return entity != null ? EntityUtils.toString(entity) : null;
					} else {
						logger.warn("Unexpected response status: " + status);
						throw new ClientProtocolException("Unexpected response status: " + status);
					}
				}
			};
			String responseBody = httpclient.execute(httpget, responseHandler);
			logger.info("----------------------------------------");
			logger.info(responseBody);
			return responseBody;
		} finally {
			httpclient.close();
		}
	}

	public static String clearMessage(final Logger logger) throws Exception {
		String message = "";
		boolean success = true;
		long sleep = 100;
		int sleepCount = 0;
		while (message == null || message.equals("")) {
			if (sleepCount < 3) {
				Thread.sleep(sleep);
				try {
					message = clearAMessage(logger);
				} catch (Exception e) {
					logger.warn(e.getMessage(), e);
					logger.warn("trying again ...");
					success = false;
				}
				sleepCount++;
				sleep = sleep + sleepCount * 100;
			} else {
				success = false;
				logger.info("still can not clear message after trying " + sleepCount + " times...");
				break;
			}
		}
		if (success) {
			return "clear message successfully, you can start a new test.";
		} else {
			return "clear message failed, please call MQTest.startMQ(log) to start test.";
		}
	}

	private static String clearAMessage(final Logger logger) throws Exception {
		CloseableHttpClient httpclient = HttpClients.createDefault();
		try {
			HttpGet httpget = new HttpGet("http://localhost:" + INTERNAL_HTTP_PORT + "/clear");
			logger.info("Executing request " + httpget.getRequestLine());
			// Create a custom response handler
			ResponseHandler<String> responseHandler = new ResponseHandler<String>() {
				public String handleResponse(final HttpResponse response) throws ClientProtocolException, IOException {
					int status = response.getStatusLine().getStatusCode();
					if (status >= 200 && status < 300) {
						HttpEntity entity = response.getEntity();
						return entity != null ? EntityUtils.toString(entity) : null;
					} else {
						logger.warn("Unexpected response status: " + status);
						throw new ClientProtocolException("Unexpected response status: " + status);
					}
				}
			};
			String responseBody = httpclient.execute(httpget, responseHandler);
			logger.info("----------------------------------------");
			logger.info("clear messages successfully.");
			return "clear messages successfully.";
		} finally {
			httpclient.close();
		}
	}

}
