package com.sap.sme.occ.product;

import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;

import org.apache.commons.lang.StringUtils;
import org.apache.http.HttpEntity;
import org.apache.http.HttpResponse;
import org.apache.http.client.ClientProtocolException;
import org.apache.http.client.ResponseHandler;
import org.apache.http.client.methods.HttpGet;
import org.apache.http.impl.client.CloseableHttpClient;
import org.apache.http.impl.client.HttpClients;
import org.apache.http.util.EntityUtils;
import org.apache.jmeter.assertions.AssertionResult;
import org.apache.jmeter.samplers.SampleResult;
import org.apache.jmeter.util.JMeterUtils;
import org.apache.log.Logger;

import com.rabbitmq.client.AMQP;
import com.rabbitmq.client.Channel;
import com.rabbitmq.client.Connection;
import com.rabbitmq.client.ConnectionFactory;
import com.rabbitmq.client.Consumer;
import com.rabbitmq.client.DefaultConsumer;
import com.rabbitmq.client.Envelope;

import com.eclipsesource.json.*;

public class MQTest {

	public static final int MQ_PORT = 5673; // 5672 for CD
	public static final String MQ_HOST = "localhost";// "rabbitmq"; for CD
	public static final int INTERNAL_HTTP_PORT = 58080;

	private static Connection mqConnection;
	private static Channel channel;

	public static Connection getMqConnection() {
		return mqConnection;
	}

	private static List<String> messages = new ArrayList<String>();

	public static List<String> getMessages() {
		return messages;
	}

	public static void killAMQConnection() throws IOException {
		mqConnection.close(0, "");
		mqConnection.abort();
		channel.close(0, "");
		channel.abort();
	}

	public static String startMQ(final Logger logger, final org.apache.jmeter.threads.JMeterVariables vars)
			throws Exception {
		String ret = "";
		boolean mqStarted = false;
		try {
			LightHttpServer.startHttpServer(INTERNAL_HTTP_PORT, logger);
		} catch (java.net.BindException e) {
			mqStarted = true;
			logger.info(e.getMessage(), e);
			ret = "reusing your last MQ connection, or you can call MQTest.stopMQ(log)/MQTest.clearMessage(log) when you finished one case, "
					+ "otherwise the message generated by your last test is cached.";
			logger.info(ret);
			// now try to clear old messages
			clearMessage(logger);
		} catch (Exception e) {
			logger.warn(e.getMessage(), e);
		}

		if (!mqStarted) {
			startAMQConnection(logger, vars);
			ret = "MQ is connected successfully, waiting for messages";
			logger.info(ret);
			System.out.println(ret);
		}

		return ret;
	}

	private static void startAMQConnection(final Logger logger, final org.apache.jmeter.threads.JMeterVariables vars)
			throws Exception {
		String host = vars.get("MQTest.mqhost");
		if (host != null && host.length() > 0) {
			logger.info("got host " + host + " from user defined variable...");
		} else {
			logger.info("NO host " + host + " from user defined variable, user localhost as default");
			host = MQ_HOST;
		}

		String port = vars.get("MQTest.mqport");
		int intPort = 0;
		try {
			intPort = Integer.parseInt(port);
		} catch (NumberFormatException e) {
			logger.warn(e.getMessage(), e);
		}

		if (intPort <= 0) {
			logger.info("incorrect port from user defined variable, use 5673 as default");
			intPort = MQ_PORT;
		} else {
			logger.info("got port " + intPort + " from user defined variable...");
		}

		ConnectionFactory factory = new ConnectionFactory();
		factory.setHost(host);
		factory.setPort(intPort);
		factory.setUsername("root");
		factory.setPassword("Initial0");
		mqConnection = factory.newConnection();
		channel = mqConnection.createChannel();

		channel.exchangeDeclare("SharedExchange", "topic", true);
		String queueName = channel.queueDeclare().getQueue();
		channel.queueBind(queueName, "SharedExchange", "Product.UPDATE.*.#");

		messages.clear();

		Consumer consumer = new DefaultConsumer(channel) {
			@Override
			public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties,
					byte[] body) throws IOException {
				String message = new String(body, "UTF-8");
				messages.add(message);
				String output = " [x] Received '" + message + "'";
				System.out.println(output);
				if (logger != null) {
					logger.info(output);
				}
			}
		};
		channel.basicConsume(queueName, true, consumer);
	}

	public static void stopMQ(final Logger logger) throws Exception {
		CloseableHttpClient httpclient = HttpClients.createDefault();
		try {
			HttpGet httpget = new HttpGet("http://localhost:" + INTERNAL_HTTP_PORT + "/exit");
			logger.info("Executing request " + httpget.getRequestLine());
			// Create a custom response handler
			ResponseHandler<String> responseHandler = new ResponseHandler<String>() {
				public String handleResponse(final HttpResponse response) throws ClientProtocolException, IOException {
					int status = response.getStatusLine().getStatusCode();
					if (status >= 200 && status < 300) {
						HttpEntity entity = response.getEntity();
						return entity != null ? EntityUtils.toString(entity) : null;
					} else {
						logger.warn("Unexpected response status: " + status);
						throw new ClientProtocolException("Unexpected response status: " + status);
					}
				}
			};
			String responseBody = httpclient.execute(httpget, responseHandler);
			logger.info("----------------------------------------");
			logger.info(responseBody);
		} finally {
			httpclient.close();
		}
	}

	public static String getMessage(final Logger logger) throws Exception {
		String message = "";
		long sleep = 100;
		int sleepCount = 0;
		while (message == null || message.equals("") || message.equals("[]")) {
			if (sleepCount < 3) {
				Thread.sleep(sleep);
				try {
					message = getAMessage(logger);
				} catch (Exception e) {
					logger.warn(e.getMessage(), e);
					logger.warn("trying again ...");
				}
				sleepCount++;
				sleep = sleep + sleepCount * 100;
			} else {
				logger.info("still can not get message after trying " + sleepCount + " times...");
				break;
			}
		}
		return message;
	}

	private static String getAMessage(final Logger logger) throws Exception {
		CloseableHttpClient httpclient = HttpClients.createDefault();
		try {
			HttpGet httpget = new HttpGet("http://localhost:" + INTERNAL_HTTP_PORT + "/messages");
			logger.info("Executing request " + httpget.getRequestLine());
			// Create a custom response handler
			ResponseHandler<String> responseHandler = new ResponseHandler<String>() {
				public String handleResponse(final HttpResponse response) throws ClientProtocolException, IOException {
					int status = response.getStatusLine().getStatusCode();
					if (status >= 200 && status < 300) {
						HttpEntity entity = response.getEntity();
						return entity != null ? EntityUtils.toString(entity) : null;
					} else {
						logger.warn("Unexpected response status: " + status);
						throw new ClientProtocolException("Unexpected response status: " + status);
					}
				}
			};
			String responseBody = httpclient.execute(httpget, responseHandler);
			logger.info("----------------------------------------");
			logger.info(responseBody);
			return responseBody;
		} finally {
			httpclient.close();
		}
	}

	public static String clearMessage(final Logger logger) throws Exception {
		String message = "";
		boolean success = true;
		long sleep = 100;
		int sleepCount = 0;
		while (message == null || message.equals("")) {
			if (sleepCount < 3) {
				Thread.sleep(sleep);
				try {
					message = clearAMessage(logger);
				} catch (Exception e) {
					logger.warn(e.getMessage(), e);
					logger.warn("trying again ...");
					success = false;
				}
				sleepCount++;
				sleep = sleep + sleepCount * 100;
			} else {
				success = false;
				logger.info("still can not clear message after trying " + sleepCount + " times...");
				break;
			}
		}
		if (success) {
			return "clear message successfully, you can start a new test.";
		} else {
			return "clear message failed, please call MQTest.startMQ(log) to start test.";
		}
	}

	private static String clearAMessage(final Logger logger) throws Exception {
		CloseableHttpClient httpclient = HttpClients.createDefault();
		try {
			HttpGet httpget = new HttpGet("http://localhost:" + INTERNAL_HTTP_PORT + "/clear");
			logger.info("Executing request " + httpget.getRequestLine());
			// Create a custom response handler
			ResponseHandler<String> responseHandler = new ResponseHandler<String>() {
				public String handleResponse(final HttpResponse response) throws ClientProtocolException, IOException {
					int status = response.getStatusLine().getStatusCode();
					if (status >= 200 && status < 300) {
						HttpEntity entity = response.getEntity();
						return entity != null ? EntityUtils.toString(entity) : null;
					} else {
						logger.warn("Unexpected response status: " + status);
						throw new ClientProtocolException("Unexpected response status: " + status);
					}
				}
			};
			String responseBody = httpclient.execute(httpget, responseHandler);
			logger.info("----------------------------------------");
			logger.info("clear messages successfully.");
			return "clear messages successfully.";
		} finally {
			httpclient.close();
		}
	}

	///////////////////////////////// Assertion Utils
	///////////////////////////////// /////////////////////////////////////////
	public static boolean assertCount(final SampleResult result, final Logger logger, String message, int count)
			throws Exception {
		JsonArray array = Json.parse(message).asArray();
		int size = array.size();
		if (size != count) {
			result.setSuccessful(false);
			result.setResponseCode("400");
			String info = "expecting " + count + " messages, but got only " + size;
			result.setResponseMessage(info);
			logger.info(info);
			return false;
		} else {
			result.setSuccessful(true);
			result.setResponseCode("200");
			String info = "there are " + count + " messages.";
			logger.info(info);
			return true;
		}
	}

	public static boolean assertProperty(final SampleResult result, final Logger logger, String message,
			String propertyName, String expectedValue) throws Exception {
		return assertProperty_Internal(result, logger, message, propertyName, expectedValue, 1);
	}

	public static boolean assertProperty(final SampleResult result, final Logger logger, String message,
			String propertyName, Integer expectedValue) throws Exception {
		return assertProperty_Internal(result, logger, message, propertyName, expectedValue, 2);
	}

	public static boolean assertProperty(final SampleResult result, final Logger logger, String message,
			String propertyName, Long expectedValue) throws Exception {
		return assertProperty_Internal(result, logger, message, propertyName, expectedValue, 3);
	}

	private static boolean StringUtils_isEmpty(String str) {
		return str == null || str.length() == 0;
	}

	private static boolean assertProperty_Internal(final SampleResult result, final Logger logger, String message,
			String propertyName, Object expectedValue, int type) throws Exception {
		if (StringUtils_isEmpty(propertyName) || result == null || logger == null || StringUtils_isEmpty(message)) {
			String info = "incorrect null parameters passed, the first 4 parameters are mandatory!!!";
			if (logger != null) {
				logger.warn(info);
			}
			if (result != null) {
				result.setSuccessful(false);
				result.setResponseCode("400");
				result.setResponseMessage(info);
			}
			return false;
		}
		boolean found = false;
		boolean foundProp = false;
		Object actualValue = null;
		JsonArray array = Json.parse(message).asArray();
		for (int i = 0; i < array.size(); i++) {
			JsonObject object = array.get(i).asObject();
			if (object.names().contains(propertyName)) {
				foundProp = true;
				switch (type) {
				case 1:// String
					actualValue = object.get(propertyName).asString();
					break;
				case 2:// Integer
					actualValue = object.get(propertyName).asInt();
					break;
				case 3:// Long
					actualValue = object.get(propertyName).asLong();
					break;
				}
				if (actualValue == null) {
					if (expectedValue == null) {
						logger.info("asseting " + propertyName + ", and both are null.");
						found = true;
					} else {
						logger.info("asseting " + propertyName + ", but got null.");
					}
				} else {
					if (actualValue.equals(expectedValue)) {
						found = true;
					}
				}
			} else {
				if (!found) {
					continue;
				} else {
					break;
				}
			}
		}
		if (found) {
			result.setSuccessful(true);
			result.setResponseCode("200");
		} else {
			result.setSuccessful(false);
			result.setResponseCode("400");
			String info;
			if (foundProp) {
				info = "expect the " + propertyName + " as " + expectedValue + ", but got " + actualValue;
			} else {
				info = "expect the " + propertyName + " as " + expectedValue + ", but not found the property";
			}
			logger.info(info);
			result.setResponseMessage(info);
		}
		return found;
	}

}
